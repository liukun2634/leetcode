## 面试题 17.14. 最小K个数

### 题目

https://leetcode-cn.com/problems/smallest-k-lcci/

### 思路1： 暴力排序

```C++
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        sort(arr.begin(), arr.end());
        vector<int> res(arr.begin(), arr.begin() + k);
        return res;
    }
};
```
时间复杂度：期望是O(nlogn)
空间复杂度：O(max(logn, k)) 排序需要

### 思路2： 大顶堆

如果是 求K 小， 用大小为 K 的大顶堆。
如果是 求K 大， 用大小为 K 的小顶堆。

```C++
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        int n = arr.size();
        //边界条件
        if(k == 0 || n == 0) return {};
        //k小，维护大顶堆
        priority_queue<int> pq;
        for(int i = 0; i < k; i++){
             pq.push(arr[i]);
        }
        for(int i = k; i < n; i++){
            if(pq.top() > arr[i]){
                pq.pop();
                pq.push(arr[i]);
            }
        }
        vector<int> res(k);
        for(int i = 0; i < k; i++){
            res[i] = pq.top();
            pq.pop();
        }
        return res;
    }
};
```

**复杂度分析**

时间复杂度：**O(nlog(k))** 其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 O(logk) 的时间复杂度, 总时间是 O(nlog(k))
空间复杂度：O(k)

### 思路3： 快速分割

来源快速排序


```C++

```

**复杂度分析**

时间复杂度：**期望是O(n), 最差为 O(n^2)**
空间复杂度：O(logn) 递归调用
