## 639. 解码方法 II

### 题目

https://leetcode-cn.com/problems/decode-ways-ii/

### 思路1： 动态规划 + 哈希表

当前位值的解码数目 = (当前位置的字符所能组成的解码数 * 前一位为结尾的解码数目) + (当前位置字符和前一位置字符所能组成双字符的解码数 * 前两位为结尾的解码数目)

定义 dp[i]是表示 s[0] - s[i - 1] 的子串达到的解码数目

我们定义两个哈希表分别记录字符串中不同组合所对应的解码方式：

map1：表示 一位字符所能对应解码的方式的个数
map2：表示 两位字符所能对应解码的方式的个数
之后就是遍历字符串，根据字符串 当前位置 和 当前位置和前一位 在 哈希表 中找到能够对应的解码方式的个数，与之前记录的次数相乘的乘积作为最后结果。

```C++
class Solution {
public:
    int MOD = 1e9 + 7;
    unordered_map<char, int> map1 ={
        {'*', 9},
        {'0', 0}, //单个0无法解码
        {'1', 1},{'2', 1},{'3', 1},{'4', 1},{'5', 1},{'6', 1},{'7', 1},{'8', 1},{'9', 1}
     
    };
    unordered_map<string, int> map2 = {
        {"1*", 9},
        {"2*", 6},
        {"*0", 2},{"*1", 2},{"*2", 2},{"*3", 2},{"*4", 2},{"*5", 2},{"*6", 2},
        {"*7", 1},{"*8", 1},{"*9", 1},
        {"10", 1},{"11", 1},{"12", 1},{"13", 1},{"14", 1},{"15", 1},{"16", 1},{"17", 1},{"18", 1},{"19", 1},
        {"20", 1},{"21", 1},{"22", 1},{"23", 1},{"24", 1},{"25", 1},{"26", 1},
        {"**", 15}
    };

    int numDecodings(string s) {
        int n = s.size();
        //dp[i]是表示 s[0] - s[i - 1] 的子串达到的解码数目
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = map1[s[0]];
        for(int i = 2; i <= n; i++){
            long long a = dp[i - 1];
            a *= map1[s[i - 1]];
            long long b = dp[i - 2];
            b *= map2[s.substr(i - 2, 2)];
            dp[i] = (a + b) % MOD;
        }
        return dp[n];
    }
};
```

**复杂度分析**

时间复杂度：O(n)
空间复杂度：O(n) 可优化为滚动数组

### 思路2： 枚举DP