### 背包问题

参考：
https://labuladong.gitbook.io/algo/mu-lu-ye-2/mu-lu-ye-2/bei-bao-wen-ti

#### 0-1 背包

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

1、明确「状态」和「选择」。 

- 状态就是「背包的容量」和「可选择的物品」。
- 选择就是「装进背包」或者「不装进背包」。


2、明确 dp 数组的定义。

dp[i][j] 的定义如下：对于前 i 个物品，当前背包的容量为 j，这种情况下可以装的最大价值是 dp[i][j]。

3、 根据「选择」，思考状态转移的逻辑。

- 如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。

- 如果你把这第 i 个物品装入了背包，那么 dp[i][j] 应该等于 dp[i-1][j - wt[i-1]] + val[i-1]。

然后dp[i][j] 应该取这两个选择的最大值。

0-1背包模板框架：

```cpp
//1.定义状态：dp[i][j] 前i个物品(0 .. i-1) 在容量j下能装下的最值
vector<vector<int>> dp(n + 1, vector<int>(w + 1));
//2.初始状态 (注意初始状态就是都不选，达到重量为0的含义)
for(int i = 0; i <= n; i++){
    dp[i][0] = ...
}

//3.转移方程
for(int i = 1; i <= n; i++) {
    for(int j = 0; j <= w; j++) {
        if(若i的大小可以放入容量为j的背包) {
            dp[i][j] = max(物品 i 装进背包, 物品 i 不装进背包)
        }
        else {
            dp[i][j] = 物品 i 不装进背包
        }
    }
}
//4. 返回结果
return dp[n][w]
```

**优化**
可以用滚动数组进行状态压缩，但是要注意遍历的方向。**j一定要从大到小遍历，这样能够保证i只会使用一次。**

```cpp
vector<int> dp(w + 1);
dp[0] = ...
for(int i = 1; i <= n; i++) {
 for(int j = w; j >= 0; j--) {
    dp[j] = max(物品 i 装进背包, 物品 i 不装进背包)
    }
}
return dp[w]
```


- [0-1背包变体：416. 分割等和子集]


#### 完全背包

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，**每个物品可以使用无限次**，现在让你用这个背包装物品，最多能装的价值是多少？

1、明确「状态」和「选择」。 

- 状态就是「背包的容量」和「可选择的物品」。
- 选择就是「装进背包」或者「不装进背包」。


2、明确 dp 数组的定义。

dp[i][j] 的定义如下：对于前 i 个物品（可重复使用），当前背包的容量为 j，这种情况下可以装的最大价值是 dp[i][j]。

3、 根据「选择」，思考状态转移的逻辑。 

- 不选择把第 i 个物品装入背包，最大价值 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。

- 选择把这第 i 个物品装入了背包，那么 dp[i][j] 应该等于 dp[i][j - wt[i-1]] + val[i-1]。（**注意只有这里与 0 - 1背包的区别，这里是 dp[i][j -wt[i-1]] + val[i - 1] 而前面是 dp[i - 1][j -wt[i-1]] + val[i - 1]**, 还是基于 前i都可选的 基础上，而不是 i - 1的基础上。

同样，dp[i][j] 应该取这两个选择的最大值。


完全背包模板：

```cpp
//1.定义状态：dp[i][j] 前i个物品(0 .. i-1) 在容量j下能装下的最值
vector<vector<int>> dp(n + 1, vector<int>(w + 1));
//2.初始状态 (注意初始状态就是都不选，达到重量为0的含义)
for(int i = 0; i <= n; i++){
    dp[i][0] = ...
}

//3.转移方程
for(int i = 1; i <= n; i++) {
    for(int j = 0; j <= w; j++) {
        if(若i的大小可以放入容量为j的背包) {
            dp[i][j] = max(物品 i-1 装进背包，是基于dp[i][j -wt[i-1]], 
                           物品 i-1 不装进背包)
        }
        else {
            dp[i][j] = 物品 i-1 不装进背包
        }
    }
}
//4. 返回结果
return dp[n][w]
```

**优化**
依然可以用滚动数组进行状态压缩，但是要注意遍历的方向。但这里j就是从小到大遍历，这样能够保证i能够被重复使用。

```cpp
vector<int> dp(w + 1);
dp[0] = ...
for(int i = 1; i <= n; i++) {
 for(int j = 0; j <= w; j++) {
    dp[j] = max(物品 i-1 装进背包, 物品 i-1 不装进背包)
    }
}
return dp[w]
```

**引申思考** 
从代码角度，是不是可以交换 i 和 j 的遍历顺序先后？其实是可以的。

如果我们可以另行定义 dp[i] 的含义：表示背包重量在i以内，能够达到的最大价值。从而写出的遍历就是：

```cpp
for(int i = 0; i <= w; i++) {
 for(int j = 1; j <= n; j++) {
    dp[i] = max(物品 j-1 装进背包, 物品 j-1 不装进背包)
    }
}
```
实际上只是不同定义的dp，产生不同的遍历和转移方程，但结果还是相同的。

题目：
- [322. 零钱兑换]
- [518. 零钱兑换 II]